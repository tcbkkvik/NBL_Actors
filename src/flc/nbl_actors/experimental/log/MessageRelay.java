/*
 * Copyright (c) 2015 Tor C Bekkvik
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
package flc.nbl_actors.experimental.log;

import flc.nbl_actors.core.*;

import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Consumer;
import java.util.function.Supplier;

/**
 * Standard message relay implementation.
 * Calls to {@link #intercept(Runnable, IGreenThr)} are logged per thread
 * to listener instances, generated by given IMsgListenerFactory
 * <p>Date 16.01.2015
 * </p>
 *
 * @author Tor C Bekkvik
 */
public class MessageRelay implements IMessageRelay {

    private static final ThreadLocal<TContext> threadContext
            = ThreadLocal.withInitial(TContext::new);
    private final IMsgListenerFactory listenerFactory;

    /**
     * @param factory Called once per real thread.
     *                Enables parallel event logging.
     *                The generator should return either
     *                (i) a single synchronized listener instance, or
     *                (ii) a separate listener per call (data may be merged later).
     */
    public MessageRelay(IMsgListenerFactory factory) {
        listenerFactory = factory;
    }

    /**
     * Set user-defined log info in a ThreadLocal variable (java.lang.ThreadLocal), to be
     * attached to next message-send log event.
     * Useful for adding labels and state information to message-trace.
     * Used when {@link IGreenThrFactory#setMessageRelay(IMessageRelay)}
     * is set with an instance of this class, and
     * consumed with first call to {@link #intercept(Runnable, IGreenThr)}.
     *
     * @param info extra log information
     */
    public static void logInfo(Supplier<String> info) {
        threadContext.get().setLogInfo(info);
    }

    public static void logInfo(String info) {
        logInfo(() -> info);
    }

    public static TContext getContext()
    {
        return threadContext.get();
    }

    private StackTraceElement stackElement(int lev) {
        final String coreP = "flc.nbl_actors.core";
        int no = 0;
        Throwable ex = new Throwable();
//                ex.printStackTrace();
        StackTraceElement[] trace = ex.getStackTrace();
        for (StackTraceElement se : trace) {
            if (++no >= lev && !se.getClassName().startsWith(coreP)) {
                return se;
            }
        }
        return null;
    }

    private TContext context() {
        TContext c = threadContext.get();
        if (c.listener == null) {
            c.listener = listenerFactory.forkListener();
        }
        return c;
    }

    @Override
    public Runnable intercept(Runnable msg, IGreenThr thread) {
        TContext ctx = context();
        IActorRef targetActor = null;
        if (msg instanceof ActorMessage) {
            ActorMessage am = (ActorMessage) msg;
            targetActor = am.ref;
        }
        final MsgSent sendEvent = new MsgSent(
                ctx.nextId(), ctx.getParentId(), ctx.getLogInfo(), stackElement(3), thread, targetActor);
        ctx.sent(sendEvent);
        return () -> {
            context().received(sendEvent);
            msg.run();
        };
    }

    /**
     * Thread Context.
     */
    public static class TContext {
        private static AtomicInteger currThrNo = new AtomicInteger();
        private final int thrNo = currThrNo.incrementAndGet();
        private int msgNo; //starts at 1 (0 is undefined)
        private MsgId parentId;
        private Supplier<String> logInfo;
        private Consumer<IMsgEvent> listener;
        private MsgReceived lastReceived;
        private MsgSent lastSent;

        private void received(MsgSent s) {
            parentId = s.id;
            listener.accept(lastReceived = new MsgReceived(s, thrNo));
        }

        private void sent(MsgSent rec) {
            listener.accept(lastSent = rec);
            logInfo = null;
        }

        public void setLogInfo(Supplier<String> info) {
            logInfo = info;
        }

        public MsgId nextId() {
            return new MsgId(thrNo, ++msgNo);
        }

        public MsgId getParentId() {
            return parentId;
        }

        public Supplier<String> getLogInfo() {
            return logInfo;
        }

        public MsgReceived getLastReceived() {
            return lastReceived;
        }

        public MsgSent getLastSent() {
            return lastSent;
        }

        /**
         * Attempt to produce a message trace-back for this thread context.
         * <p>(returns empty list if IMsgListenerFactory does not implement IMsgTrace)
         * </p>
         *
         * @return message trace
         */
        public List<IMsgEvent> getMessageTrace() {
            List<IMsgEvent> list = new LinkedList<>();
            if (lastReceived != null && listener instanceof IMsgTrace) {
                ((IMsgTrace) listener)
                        .getMessageTrace(lastReceived.id(), list::add);
            }
            return list;
        }

    }
}
